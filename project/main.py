import json
import logging
import secrets
import time
import uuid

import click
from click import Context
from jinja2 import Environment, PackageLoader, select_autoescape
from keycloak import KeycloakOpenIDConnection, KeycloakAdmin, KeycloakOpenID


@click.group()
@click.option(
    "--kc-server-url",
    default="http://localhost:8080/",
    help="URL to Keycloak instance.",
)
@click.option(
    "--kc-realm-name",
    "-r",
    default="flame",
    help="Name of realm within Keycloak to create.",
)
@click.option(
    "--verify/--no-verify",
    default=True,
    help="Enable certificate validation for encrypted traffic.",
)
@click.pass_context
def cli(ctx: Context, kc_server_url: str, kc_realm_name: str, verify: bool):
    ctx.ensure_object(dict)
    ctx.obj["kc_server_url"] = kc_server_url
    ctx.obj["kc_realm_name"] = kc_realm_name
    ctx.obj["verify"] = verify


@cli.command()
@click.pass_context
def get_public_key(ctx: Context):
    """
    Retrieves the public key of a Keycloak for a specific realm.
    """
    kc_server_url = ctx.obj["kc_server_url"]
    kc_realm_name = ctx.obj["kc_realm_name"]
    verify = ctx.obj["verify"]
    try:
        # Connect to Keycloak OpenID without login
        kc_client_oid = KeycloakOpenID(
            server_url=kc_server_url,
            realm_name=kc_realm_name,
            verify=verify,
            client_id="dummy_client_id",
        )

        # Fetching public key
        public_key = kc_client_oid.public_key()

        # Format key to PEM format
        pem_public_key = "-----BEGIN PUBLIC KEY-----\n"
        for i in range(0, len(public_key), 64):
            pem_public_key += public_key[i : i + 64] + "\n"
        pem_public_key += "-----END PUBLIC KEY-----"

        click.echo(
            f"Public Key for realm '{kc_realm_name}' in PEM format:\n{pem_public_key}"
        )
    except Exception as e:
        click.echo(f"Failed to retrieve public key: {str(e)}")


@cli.command()
@click.option(
    "--token-type",
    "-t",
    default="access",
    type=click.Choice(["access", "id"]),
    help="Type of token to return.",
)
@click.argument("kc_client_id", metavar="CLIENT_ID")
@click.argument("kc_client_secret", metavar="CLIENT_SECRET")
@click.pass_context
def token(
    ctx: Context,
    token_type: str,
    kc_client_id: str,
    kc_client_secret: str,
):
    kc_server_url = ctx.obj["kc_server_url"]
    kc_realm_name = ctx.obj["kc_realm_name"]
    verify = ctx.obj["verify"]

    kc_client_oid = KeycloakOpenID(
        server_url=kc_server_url,
        realm_name=kc_realm_name,
        client_id=kc_client_id,
        client_secret_key=kc_client_secret,
        verify=verify,
    )

    token = kc_client_oid.token(grant_type="client_credentials")

    match token_type:
        case "access":
            token_prop = "access_token"
        case "id":
            token_prop = "id_token"
        case _:
            raise ValueError(f"unknown token type `{token_type}`")

    print(token[token_prop])


@cli.command()
@click.option(
    "--kc-master-realm-name",
    default="master",
    help="Name of master realm within Keycloak.",
)
@click.option(
    "--kc-client-name",
    "-c",
    default=["flame-client"],
    help="Name of client within Keycloak realm to create.",
    multiple=True,
)
@click.argument("kc_admin_username", metavar="ADMIN_USERNAME")
@click.argument("kc_admin_password", metavar="ADMIN_PASSWORD")
@click.pass_context
def run(
    ctx: Context,
    kc_admin_username: str,
    kc_admin_password: str,
    kc_master_realm_name: str,
    kc_client_name: list[str],
) -> None:
    def _uuid4() -> str:
        return str(uuid.uuid4())

    kc_server_url = ctx.obj["kc_server_url"]
    kc_realm_name = ctx.obj["kc_realm_name"]
    verify = ctx.obj["verify"]

    # set up jinja env
    env = Environment(
        loader=PackageLoader("project"),
        autoescape=select_autoescape(),
    )
    env.globals["uuid4"] = _uuid4

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("kcsetup")

    kc_admin_oid = KeycloakOpenIDConnection(
        server_url=kc_server_url,
        username=kc_admin_username,
        password=kc_admin_password,
        realm_name=kc_master_realm_name,
        verify=verify,
    )

    kc_admin = KeycloakAdmin(connection=kc_admin_oid)

    # load realm payload
    realm_payload = json.loads(
        env.get_template("realm.json.tmpl").render(
            realm_name=kc_realm_name,
        )
    )

    # retrieve uuid generated by template
    kc_realm_uuid = realm_payload["id"]

    logger.info(
        "Read realm payload, creating new realm `%s` (%s)", kc_realm_name, kc_realm_uuid
    )

    # create realm and perform sanity check
    kc_admin.create_realm(realm_payload)
    kc_realm = kc_admin.get_realm(kc_realm_name)

    assert kc_realm["id"] == kc_realm_uuid
    assert kc_realm["realm"] == kc_realm_name

    logger.info("Realm successfully created")

    # switch realms
    kc_admin.change_current_realm(kc_realm_name)

    kc_clients: list[tuple[str, str]] = []

    for kc_client_id in kc_client_name:
        kc_client_secret = secrets.token_urlsafe(24)  # creates 32 char url-safe secret

        # load client payload
        client_payload = json.loads(
            env.get_template("client.json.tmpl").render(
                client_id=kc_client_id,
                client_secret=kc_client_secret,
                client_secret_creation_time=int(time.time()),
            )
        )

        logger.info("Read client payload, creating new client `%s`", kc_client_id)

        # create client and perform sanity check
        kc_client_uuid = kc_admin.create_client(client_payload)
        kc_client = kc_admin.get_client(kc_client_uuid)

        assert kc_client["clientId"] == kc_client_id
        assert kc_client["secret"] == kc_client_secret

        logger.info("Client successfully created")

        # check whether authentication works
        kc_client_oid = KeycloakOpenID(
            server_url=kc_server_url,
            realm_name=kc_realm_name,
            client_id=kc_client_id,
            client_secret_key=kc_client_secret,
            verify=verify,
        )

        auth_token = kc_client_oid.token(grant_type="client_credentials")

        assert auth_token is not None

        kc_clients.append(
            (
                kc_client_id,
                kc_client_secret,
            )
        )
        logger.info("Authentication successful")

    print("")
    print("=" * 64)
    print("")
    print(f"Realm: {kc_realm_name}")

    for i in range(len(kc_clients)):
        kc_client_id, kc_client_secret = kc_clients[i]

        print("")
        print(f"Client #{i + 1} ID: {kc_client_id}")
        print(f"Client #{i + 1} Secret: {kc_client_secret}")

    print("")
    print("=" * 64)
    print("")


if __name__ == "__main__":
    cli(obj={})
